<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[隆街欧阳氏的来源：我和欧阳修有没有血脉关系？]]></title>
      <url>/2018/05/02/%E9%9A%86%E8%A1%97%E6%AC%A7%E9%98%B3%E6%B0%8F%E7%9A%84%E6%9D%A5%E6%BA%90%EF%BC%9A%E6%88%91%E5%92%8C%E6%AC%A7%E9%98%B3%E4%BF%AE%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A1%80%E8%84%89%E5%85%B3%E7%B3%BB%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h1 id="我是谁？"><a href="#我是谁？" class="headerlink" title="我是谁？"></a>我是谁？</h1><p>我叫欧高均，出生自广东省河源市连平县隆街镇龙埔村。性别男，汉族，一名普通学生。性取向女。</p>
<hr>
<h1 id="欧阳修"><a href="#欧阳修" class="headerlink" title="欧阳修"></a>欧阳修</h1><p>”酸师傅，快看，欧阳修！姓欧阳的噢！哈哈，厉害吧？”</p>
<p>”切，欧阳修厉害和你有屁关系？”</p>
<p>”我，他，他可能是我的老祖宗！”</p>
<p>”吹吧，天下姓欧的那么多，你说是就是啊！”</p>
<p>”不跟你玩儿了。”</p>
<p>九年级的时候学到《醉翁亭记》和同桌开的玩笑，当时确实只是讲讲笑，没想着深究欧阳修是不是我直系祖宗，同桌反怼一波我自己也默认了和欧阳修在血缘上没有任何瓜葛。</p>
<p>五一在家，老爸和亲友一次闲聊中，我听到他说我们姓欧的是从江西吉安迁徙过来的，然后又扯到欧阳修，虽然我知道我爸有很大嫌疑是在吹水装逼，但是这却引起了我的好奇心。</p>
<p>于是我就趁着这股好奇劲儿去找我们村欧阳的来源。也想知道和欧阳修到底有没有关系。</p>
<hr>
<h1 id="字辈"><a href="#字辈" class="headerlink" title="字辈"></a>字辈</h1><p>搜寻资料肯定先百度，于是我基本将关于<a href="https://baike.baidu.com/item/%E6%AC%A7%E9%98%B3%E5%A7%93/6399302" target="_blank" rel="noopener">欧阳姓</a>的百度百科看完了。对欧阳有了大概的了解，但是对于迁徙还是没有太大收货，感到有些可惜。</p>
<p>但是至少知道广东的欧阳氏基本都是来自江西的。</p>
<p>不知道如何下手去找资料。突然想到我们姓氏是有分字辈的，然后我就去问我奶奶关于我们欧阳姓的字辈，我只知道我是<code>可</code>字辈的，其他的都不大了解。奶奶说她也不大清楚，只知道我是<code>可</code>字辈，我爸是<code>克</code>字辈，再老一辈是<code>汝</code>字辈，有个邻居更大一辈，是<code>光</code>字辈的，其他就不知道了。</p>
<p>我就拿到这几个字辈，再去搜索，找到了不少信息。</p>
<p>在 <a href="https://baike.baidu.com/item/%E5%AD%97%E8%BE%88/6537601" target="_blank" rel="noopener">字辈</a> 的百度百科看到这样一句。</p>
<blockquote>
<p>江西欧阳氏字辈“仲国淑景，高先以民（宋淳熙派），永广时之，崇曰文思（明永乐派），充士正立，今尚愈光，汝克可效，天兆孔良（明弘治派），彝伦攸叙，寿尔载尝，保佑盛鼎，厥后定昌（清嘉庆派）”等等，这些都算是比较优秀的四言类诗体字辈。</p>
</blockquote>
<p>这确实是来自江西的欧阳氏的字辈，总共有48个字辈。</p>
<p>然后，在一个<a href="https://tieba.baidu.com/f?kz=598330115" target="_blank" rel="noopener">贴吧</a>里看到这样一个图。</p>
<p><img src="/2018/05/02/隆街欧阳氏的来源：我和欧阳修有没有血脉关系？/img1.png" alt=""></p>
<p>一下子欣喜若狂，因为看到沐河了。</p>
<hr>
<h1 id="沐河村"><a href="#沐河村" class="headerlink" title="沐河村"></a>沐河村</h1><p>这是一个神奇的村子，除了几户从其他地方搬进来的，整个村子都姓欧阳。</p>
<p>那，和我们有什么关系呢？</p>
<p>必须得有关系，因为我们也姓欧阳，也许你会感到奇怪我的姓名里没有<code>阳</code>字，但我的出生证上写的是欧阳高均。我自己也有一些疑惑，通过了解，欧、区和欧阳都是同一个姓，至于具体为什么会变，可能有很多无关痛痒的因素，比如为了迎合单字姓，或者偷懒故意写少个，或者只是觉得叫起来比较顺口之类的。</p>
<p>在我影响中，沐河有一次修建欧阳氏祠堂的时候，我们龙埔以及隔壁有姓欧/欧阳的人都要求出钱出力，这就更能说明我们周边村子姓欧的都是来自沐河村。</p>
<p>在搜寻资料的过程中，发现了 <code>《欧阳谱志》(1993年广东连平沐河—广东槎江系秀甫公续谱)</code> ，而且这是在广东来说，是一本较完善的欧阳氏族谱，也是沐河欧阳氏的家谱，里面有我想要的答案。当然，我不知道他在哪，也没见过它，只是找资料的时候很经常看到引用它的文章或者帖子。</p>
<hr>
<h1 id="彤公后世"><a href="#彤公后世" class="headerlink" title="彤公后世"></a>彤公后世</h1><p>欧阳彤，字光国，唐武宗会昌间（841—846）进士，初为吉州令，后授校书郎，集贤校理，累官工部尚书，绪公次子，琮公八世孙。</p>
<p>总之，是个挺牛逼的人，而且，是我的直系祖宗。</p>
<p>然后呢？</p>
<p>结合上面那张来自<a href="https://tieba.baidu.com/f?kz=598330115" target="_blank" rel="noopener">贴吧</a>的图<br><img src="/2018/05/02/隆街欧阳氏的来源：我和欧阳修有没有血脉关系？/img2.png" alt=""></p>
<p>还有<code>《欧阳谱志》(1993年广东连平沐河—广东槎江系秀甫公续谱)</code>，可以看出，<strong>秀莆公</strong>是沐河的开基先祖。</p>
<p>而资料显示，欧阳秀莆是欧阳彤的后世。</p>
<blockquote>
<p>欧阳绪(第43代) – 欧阳彤(第44代,欧阳国光,蜀江派始祖) –<br>欧阳泽(第45代,欧阳必润) – 欧阳雄(第46代) – 欧阳勋(第47代) –<br>欧阳坦(第48代) – 欧阳郢(第49代) – 欧阳忠(第50代,欧阳政直,常溪始祖) –<br>欧阳馆(第51代,欧阳大郎,濂江派安远始祖) – 欧阳威(第52代,欧阳二郎) –<br>欧阳圣训(第53代,欧阳振铎) – 欧阳玑(第54代,欧阳玉衡) –<br>欧阳伯论(第55代,欧阳五郎) – 欧阳衍祖(第56代,欧阳绳武) –<br>欧阳必田(第57代) – 欧阳泳夫(第58代) – 欧阳秀甫(第59代),沐河开基先祖元秀公</p>
</blockquote>
<p>这里最开始来到河源的并不是欧阳秀甫，而是<strong>欧阳泳夫</strong>。</p>
<blockquote>
<p>始迁祖欧阳泳夫，元朝进士，官任广东按察司签事， 携眷由赣迁粤，定居河源，是元代槎江派欧阳氏族始祖。</p>
</blockquote>
<p>所以，到这里，我的身世就很明确了，但我爸说的我们来自江西吉安，这句话可以说对也可以说不对。江西是肯定的，说吉安的话，那么多代祖宗，确实有很多在吉安呆过，所以这句话可以说是对的。但我们不是直接从吉安迁徙过来的，是经过几十代最终在这定居下来，所以这句话也可说不对。</p>
<p>但现在考究这个没什么意义，主要已经将整个从江西迁徙到沐河的欧阳世代搞清楚了，也就知道我们的来源了，生自哪里不重要，重要是来自哪里。</p>
<p>那么，为什么要从欧阳彤说起，而不是更早一代呢？</p>
<hr>
<h1 id="彪、彤、万三派分宗"><a href="#彪、彤、万三派分宗" class="headerlink" title="彪、彤、万三派分宗"></a>彪、彤、万三派分宗</h1><p>欧阳彤的后世渐渐迁徙到广东各个地区，但最早到广东的，并不是他的后世，而是他的哥哥，欧阳彪。</p>
<p>43代，御史大夫欧阳绪有三个儿子：欧阳彪、欧阳彤、欧阳万。</p>
<p>大儿子欧阳彪被朝廷授予广东刺史，于是举家迁往广东，为广东初祖，是为番禹派；</p>
<p>二儿子欧阳彤常溪，复迁蜀江，是为蜀江派；</p>
<p>小儿子欧阳万当了安福县令，举家迁往安福，是为安福派，又叫庐陵派。</p>
<hr>
<p>本节资料来自：<a href="http://www.8dou.net/html/article_cpshow_2088.shtml" target="_blank" rel="noopener">http://www.8dou.net/html/article_cpshow_2088.shtml</a></p>
<hr>
<h3 id="彪"><a href="#彪" class="headerlink" title="彪"></a>彪</h3><p>欧阳彪初为江西安福县令，唐僖宗乾符（874—879）年间擢广州刺史，而这段时期江西安福县令则由其第欧阳万担任。</p>
<p>旧谱据载彪公后世不久失传，实际有后裔在广东番禺一带。</p>
<p>据《欧阳谱志》所载，彪公后世子孙多居住在广东省。如广东从化、分花县杨村、大田、沙蚬、番禺珠刚、江村、高塘、珠村石狮岭、南海横冈、长沙埠、横潭等地。</p>
<blockquote>
<p>“八世彪彤万兄弟，彪徙广州系久亡”这两句原载于《欧阳氏图谱》，其实彪公到广州担任刺史以后，是有后人的。只不过当时由于各种原因，导致欧阳修撰写《欧阳氏图谱》的时候无法考证到。结果在这之后的各支族修谱都照原样誊抄，也没有重新加以考证了。使得彪公的后代“失传”。</p>
<p>一次偶然的机会在瑞金市沙洲坝镇洁源村菱角塘的一位宗亲的私祠里面看到《欧阳谱志》（广东连平沐河谱），但是真是如获至宝，欣喜万分。里面有几页专门介绍彪公在广东繁衍的世系表。现照排于此，让欧阳世家的人都能了解到其中的实情，所谓彪、彤、万三支分派后彪公系久亡的说法是错误的。（载于1993年广东连平沐河《欧阳谱志》第291—293页）</p>
</blockquote>
<p>节选自：<a href="http://www.8dou.net/html/article_cpshow_2088.shtml" target="_blank" rel="noopener">http://www.8dou.net/html/article_cpshow_2088.shtml</a></p>
<h3 id="彤"><a href="#彤" class="headerlink" title="彤"></a>彤</h3><p>欧阳彤也是一位成绩斐然的人物，他于唐武宗会昌时（841—846）登进士，初为吉州县令，后授校书郎，集贤校理，累官工部尚书。欧阳彤生了五个儿子，前面三个儿子如今查不到他们的名字了，只知道都居住在郡北（也就是赣北，今江西省北部地区）；第四个儿子叫欧阳泽；第五个叫欧阳沄，居郡南（今抚州、赣南一带）。</p>
<p>后来欧阳氏彤公这一派自庐陵迁居到常溪，又从常溪分居到濂江（今江西安远县）、蜀江。</p>
<p>宋元期间，欧阳世家在庐陵吉水这块风水宝地繁衍，人数达到空前之多。蜀江派的第三代有一位叫廿一承事（即是忻先）的人，他非常有能力，且才华横溢，于是在宋乾道间（1165—1173年）担任广东副都统，落籍从化凤院。后世子孙分布在广东从化、会城双井街等地。</p>
<p>忻先有个弟弟叫廿二承事（即是仲先），他没有做官，子孙后代却十分兴旺。等他长大后娶了为姓郭的小姐，生了五个儿子。后世子孙分布在蜀江、泰和、广东南雄保昌、广东增城清湖、广东新会、瑞金、于都、东莞、新安、大鹏、九连山、梅州、等地。</p>
<h3 id="万"><a href="#万" class="headerlink" title="万"></a>万</h3><p>欧阳万于僖宗乾符（874—879）年间当了安福县令，举家迁往安福，后来成为庐陵大族。也成了江南各省欧阳姓氏的一个源头，出了不少名人。北宋的一代文宗、唐宋八大家之一的欧阳修便是庐陵人。他也自称“庐陵欧阳修”。</p>
<p>天复四年（904年）八月，朱全忠杀宣帝，立李柷为皇帝（史称唐哀帝），天佑四年（907年）帝僤位于朱全忠，唐亡，帝被封为济阴王，次年被鸩杀（一种鸩羽浸泡的酒，有剧毒，古代皇帝多赐罪犯喝鸩酒而杀之）。</p>
<p>公元937年，南唐在金陵（今南京）建立。欧阳家族有一位人物被任命为武昌令，他就是欧阳氏安福始祖万公第六世孙欧阳郴。后来担任检校右散骑常侍兼御史大夫，封赠金紫光禄大夫、太师中书令。</p>
<p>欧阳郴的孙子欧阳观历任道州等地的判官。可惜欧阳观只活了59就去世了，不过他却有一位名誉华夏的儿子欧阳修。</p>
<p>从欧阳万到欧阳修，共有9代。源流图如下（据清乾隆十五年《续修安福令欧阳公通谱》派定）：</p>
<p>1、万（唐安福令） →  2、诚  → 3、雅 → 4、效（韶阳主簿）→ 5、託 → 6、郴（南唐大夫） → 7、偃（南京街判官） → 8、观（崇国公） → 9、修（江西永丰人，字永叔，号醉翁，又号六一居士，北宋文学家，官居参知政事（副宰相）《宋史》有传）</p>
<hr>
<p>欧阳家族的人散居在江南各省，在吉水、安福、永丰等地直到宋代，宋末，随北方少数民族南下，于是欧阳宗族也分散到了广东的新会、中山，广西的桂林、浏阳，湖南的宁乡、湘潭、新化、益阳、江永、桂阳、郴（chēn）县，江西的安福、万载、婺源，湖北的枝江、仙桃镇，浙江的兰溪以及河南、台湾等地。</p>
<hr>
<p>从上面三兄弟的资料可以知道，我是彤公后世，而欧阳修是万公后世，也就是说我和欧阳修不是直脉关系，而是支脉关系。所以他是我祖宗这句话，是不正确的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>天下欧阳一家亲。</p>
<p>当然，不只欧阳，所有的姓氏，只要是相同姓氏的，说不定一千年前就是一家人。当然，扯这个没用，家里有个俗语（经过我修改后的，但大致意思不变）：一代亲，两代好，三代眼瞄瞄，四代鸟都不鸟。也就是说到了第四代，可以说基本就没有血缘关系了，在交际关系上也基本没啥联系了。按照科学的说法，三代后也能通婚了。</p>
<p>我住的村子，有六个姓：李，欧，江，潘，薛，张。（不分先后）</p>
<p>可能每个姓都有自己的故事，这么多姓，又是怎样汇集到一个村子里一起生活发展，还有就是看，当时为什么龙埔或者其他村那些姓欧的人要从沐河搬出来？</p>
<p>很多事，我很好奇，虽然我不是这方面的专家或者需要在这方面做研究之类的，但我希望在以后的日子里，我能了解到更多关于我们村，我们姓氏的故事。</p>
<h6 id="—-我叫欧高均，来自龙埔村。"><a href="#—-我叫欧高均，来自龙埔村。" class="headerlink" title="— 我叫欧高均，来自龙埔村。"></a>— 我叫欧高均，来自龙埔村。</h6><hr>
<p>本文大部分资料来自互联网，可能存在真实性错误的地方，如有建议或者错误，可以发送邮件至：<a href="mailto:1920363953@qq.com" target="_blank" rel="noopener">1920363953@qq.com</a> 或者博客评论进行反馈，谢谢。</p>
]]></content>
      
        <categories>
            
            <category> 日常吹水 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 欧阳 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python获取详细时间：time模块]]></title>
      <url>/2018/04/27/Python%E8%8E%B7%E5%8F%96%E8%AF%A6%E7%BB%86%E6%97%B6%E9%97%B4%EF%BC%9Atime%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="Time模块"><a href="#Time模块" class="headerlink" title="Time模块"></a>Time模块</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>关于Python的<code>Time</code>模块的详细的函数功能和介绍可以看这篇文章：</p>
<p><a href="https://www.cnblogs.com/renpingsheng/p/6965044.html" target="_blank" rel="noopener">https://www.cnblogs.com/renpingsheng/p/6965044.html</a></p>
<h3 id="计算代码运行时长"><a href="#计算代码运行时长" class="headerlink" title="计算代码运行时长"></a>计算代码运行时长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回当前时间戳（1970纪元后进过的浮点秒数）</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment"># 耗时操作</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>**<span class="number">8</span>)]</span><br><span class="line"><span class="comment"># 再次获取</span></span><br><span class="line">end = time.time()</span><br><span class="line"><span class="comment"># 总耗时等于后面的时间戳减去前面的</span></span><br><span class="line">print(<span class="string">'总耗时：'</span>, end-start, <span class="string">'秒'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总耗时： 4.603348016738892 秒</span><br></pre></td></tr></table></figure>
<h3 id="获取详细的时间信息"><a href="#获取详细的时间信息" class="headerlink" title="获取详细的时间信息"></a>获取详细的时间信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以时间元组(struct_time)的形式返回</span></span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line"><span class="comment"># 输出元组</span></span><br><span class="line">print(localtime)</span><br><span class="line"><span class="comment"># 取年份</span></span><br><span class="line">print(<span class="string">"当前年份："</span>, localtime[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h5 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=2018, tm_mon=4, tm_mday=26, tm_hour=10, tm_min=50, tm_sec=24, tm_wday=3, tm_yday=116, tm_isdst=0)</span><br><span class="line">当前年份： 2018</span><br></pre></td></tr></table></figure>
<h4 id="返回元组的解析"><a href="#返回元组的解析" class="headerlink" title="返回元组的解析"></a>返回元组的解析</h4><table>
<thead>
<tr>
<th>索引值(index)</th>
<th>属性(Attribute)</th>
<th>值(Values)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>tm_year(年)</td>
<td>(例如:2015)</td>
</tr>
<tr>
<td>1</td>
<td>tm_mon(月)</td>
<td>1-12</td>
</tr>
<tr>
<td>2</td>
<td>tm_mday(日)</td>
<td>1-31</td>
</tr>
<tr>
<td>3</td>
<td>tm_hour(时)</td>
<td>0-23</td>
</tr>
<tr>
<td>4</td>
<td>tm_min(分)</td>
<td>0-59</td>
</tr>
<tr>
<td>5</td>
<td>tm_sec(秒)</td>
<td>0-61(60代表闰秒,61是基于历史原因保留)</td>
</tr>
<tr>
<td>6</td>
<td>tm_wday(星期几)</td>
<td>0-6(0表示星期一)</td>
</tr>
<tr>
<td>7</td>
<td>tm_yday(一年中的第几天)</td>
<td>1-366</td>
</tr>
<tr>
<td>8</td>
<td>tm_isdst(是否为夏令时)</td>
<td>0,1,-1(-1代表夏令时)</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python数组：array模块]]></title>
      <url>/2018/04/27/Python%E6%95%B0%E7%BB%84%EF%BC%9Aarray%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="Python数组"><a href="#Python数组" class="headerlink" title="Python数组"></a>Python数组</h1><h3 id="为什么要用数组"><a href="#为什么要用数组" class="headerlink" title="为什么要用数组"></a>为什么要用数组</h3><p>列表（list）既灵活又简单，但面对各种需求的时候，比如，存放1000万个浮点数的话，数组（array）的效率就比列表高很多。因为数组背后存放的并不是float对象，而是数字的机器翻译，也就是字节表述。就跟C语言的数组一样。</p>
<h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p>导入Python自带的<code>array</code>模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个整数数组</span></span><br><span class="line">a = array(<span class="string">'i'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># a是一个数组对象</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以像列表一样使用数组</span></span><br><span class="line">print(<span class="string">'第二个元素'</span>, a[<span class="number">2</span>])</span><br><span class="line">print(<span class="string">'遍历输出数组:'</span>)</span><br><span class="line">[print(element) <span class="keyword">for</span> element <span class="keyword">in</span> a]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 能直接转成列表对象</span></span><br><span class="line">print(list(a))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array(&apos;i&apos;, [1, 2, 3])</span><br><span class="line">第二个元素 3</span><br><span class="line">遍历输出数组:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="数组创建的类型"><a href="#数组创建的类型" class="headerlink" title="数组创建的类型"></a>数组创建的类型</h3><p>由上面的例子可以看出，创建数组就是执行了这条代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = array(<span class="string">'i'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>第一个参数是<code>Typecode</code>，例如这里参数的<code>&#39;i&#39;</code>决定了数组元素的类型为整数。以下是Python数组所有的类型（Python3.6）：</p>
<table>
<thead>
<tr>
<th>Type code</th>
<th>C Type</th>
<th>Python Type</th>
<th>Minimum size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>signed char</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td><code>&#39;B&#39;</code></td>
<td>unsigned char</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td><code>&#39;u&#39;</code></td>
<td>Py_UNICODE</td>
<td>Unicode character</td>
<td>2</td>
</tr>
<tr>
<td><code>&#39;h&#39;</code></td>
<td>signed short</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td><code>&#39;H&#39;</code></td>
<td>unsigned short</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td><code>&#39;i&#39;</code></td>
<td>signed int</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td><code>&#39;I&#39;</code></td>
<td>unsigned int</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td><code>&#39;l&#39;</code></td>
<td>signed long</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td><code>&#39;L&#39;</code></td>
<td>unsigned long</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td><code>&#39;q&#39;</code></td>
<td>signed long long</td>
<td>int</td>
<td>8</td>
</tr>
<tr>
<td><code>&#39;Q&#39;</code></td>
<td>unsigned long long</td>
<td>int</td>
<td>8</td>
</tr>
<tr>
<td><code>&#39;f&#39;</code></td>
<td>float</td>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td><code>&#39;d&#39;</code></td>
<td>double</td>
<td>float</td>
<td>8</td>
</tr>
</tbody>
</table>
<h3 id="array的方法"><a href="#array的方法" class="headerlink" title="array的方法"></a>array的方法</h3><p>详细看：</p>
<p><a href="https://docs.python.org/3.6/library/array.html" target="_blank" rel="noopener">https://docs.python.org/3.6/library/array.html</a></p>
<p>有需求我再补充这部分。</p>
<h3 id="tofile和fromfile方法"><a href="#tofile和fromfile方法" class="headerlink" title="tofile和fromfile方法"></a>tofile和fromfile方法</h3><p>这两个方法是<code>array</code>自带的序列化方法，可以将对象写到一个二进制文件，也可以通过读取这个二进制文件获取里面的<code>array</code>对象。而且速度非常快。</p>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一千万个随机数</span></span><br><span class="line">floats = array(<span class="string">'d'</span>, [random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">7</span>)])</span><br><span class="line"><span class="comment"># 输出最后一个数</span></span><br><span class="line">print(floats[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 将对象写到二进制文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./floats.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    floats.tofile(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的数组对象</span></span><br><span class="line">floats2 = array(<span class="string">'d'</span>)</span><br><span class="line"><span class="comment"># 读取二进制文件的array对象</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./floats.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    floats2.fromfile(file, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line"><span class="comment"># 输出读取到的对象最后一个元素</span></span><br><span class="line">print(floats2[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断两个对象元素是否相等</span></span><br><span class="line">print(floats == floats2)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.87578592028721</span><br><span class="line">0.87578592028721</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>这里从文件读取对象只需要0.1秒的时间，比从文本文件读取的速度要快60倍。</p>
<p>另外还可以用<code>pickle</code>模块进行序列化，速度几乎和上面例子差不多，但是它可以处理任何对象的序列化。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python序列的增量赋值运算]]></title>
      <url>/2018/03/04/Python%E5%BA%8F%E5%88%97%E7%9A%84%E5%A2%9E%E9%87%8F%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="Python序列的增量赋值"><a href="#Python序列的增量赋值" class="headerlink" title="Python序列的增量赋值"></a>Python序列的增量赋值</h1><p>Python增量赋值运算符有<code>+=</code>和<code>*=</code>，他们背后的原理就是使用了特殊方法。</p>
<p><code>+=</code>背后的特殊方法是<code>__iadd__</code>，用于就地加法，也就是不生成新的序列，在当前序列直接进行增加。但如果一个类没有实现<code>__iadd__</code>，那么Python就会退一步调用<code>__add__</code>。</p>
<p>看看以下这个表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a += b</span><br></pre></td></tr></table></figure>
<p>如果<code>a</code>实现了<code>__iadd__</code>方法，就会调用这个方法。对于<a href="http://ougaojun.com/2018/02/15/Python%E5%86%85%E7%BD%AE%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/#%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">可变序列</a>来说，<code>a</code>就会就地改动，就像调用了<code>a.extend(b)</code>一样。</p>
<p>否则，这个表达式就会和<code>a = a + b</code>一样，得到一个新的序列，然后赋值给<code>a</code>。</p>
<p>而<code>*=</code>也一样，相对应实现的特殊方法是<code>__imul__</code>。</p>
<p>下面一个例子可以展示可变和不可变序列上的区别和作用。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [1,2,3]	# 可变序列</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">4598204552</span><br><span class="line">&gt;&gt;&gt; l *= 2</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">4598204552</span><br><span class="line">&gt;&gt;&gt; t = (1,2,3)	# 不可变序列</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">4598382312</span><br><span class="line">&gt;&gt;&gt; t *= 2</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, 3, 1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">4594789064</span><br></pre></td></tr></table></figure>
<h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p>可变类型进行增量运算之后，内存地址并没有改变，而不可变类型就改变了。</p>
<p>所以，对不可变类型进行重复拼接操作的话，效率就会很低，因为每次都会产生一个新的序列。</p>
<h2 id="一个关于-的谜题"><a href="#一个关于-的谜题" class="headerlink" title="一个关于+=的谜题"></a>一个关于+=的谜题</h2><p>看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2, [30, 40])</span><br><span class="line">&gt;&gt;&gt; t[2] += [50, 60]</span><br></pre></td></tr></table></figure>
<p>这里，你觉得会发生下列哪一种情况：</p>
<ul>
<li>a. t 变成 (1, 2, [30, 40, 50, 60])。</li>
<li>b. 因为 tuple 不支持对它的元素赋值，所以会抛出 TypeError 异常。</li>
<li>c. 以上两个都不是。</li>
<li>d. a 和 b 都是对的。</li>
</ul>
<p>这里的话，分析一下代码，<code>t</code>是不可变序列，应该是选<code>b</code>。</p>
<p>我们运行一下代码，得到下面结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#12&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    t[2] += [50, 60]</span><br><span class="line">TypeError: &apos;tuple&apos; object does not support item assignment</span><br></pre></td></tr></table></figure>
<p>看来确实是选择<code>b</code>，但是，再看看<code>t</code>的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, [30, 40, 50, 60])</span><br></pre></td></tr></table></figure>
<p>what the f*ck !??</p>
<p><img src="http://07.imgmini.eastday.com/mobile/20171017/20171017045451_1d939f2d4f0edad71f85f1afb779ff88_4.jpeg" alt=""></p>
<p>也就是说，正确答案是<code>d</code>。</p>
<p>那为什么会这样呢？看看以下例子解析</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(&apos;s[a] += b&apos;)</span><br><span class="line">  1           0 LOAD_NAME                0 (s)</span><br><span class="line">              2 LOAD_NAME                1 (a)</span><br><span class="line">              4 DUP_TOP_TWO</span><br><span class="line">              6 BINARY_SUBSCR</span><br><span class="line">              8 LOAD_NAME                2 (b)</span><br><span class="line">             10 INPLACE_ADD</span><br><span class="line">             12 ROT_THREE</span><br><span class="line">             14 STORE_SUBSCR</span><br><span class="line">             16 LOAD_CONST               0 (None)</span><br><span class="line">             18 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这是对<code>s[a] += b</code>这个表达式进行运算的底层实现过程。假设<code>s</code>是上面的<code>t</code>那个例子。</p>
<p><code>6 BINARY_SUBSCR</code>：这行将<code>s[a]</code>的值存入栈顶(TOS, Top Of Stack), <code>TOS = s[a]</code></p>
<p><code>10 INPLACE_ADD</code>：计算<code>TOS += b</code>。这步能正常执行，因为<code>TOS</code>指向的是一个可变对象。</p>
<p><code>14 STORE_SUBSCR</code>：<code>s[a] = TOS</code>赋值操作，这里发生了失败，因为<code>s</code>是不可变序列。</p>
<p>这里就能看出，它是先执行元素内增量操作的，后面因为触发不变序列的赋值操作导致报错。这里虽然报错，但是还是操作成功的。</p>
<hr>
<p>确实是个很搞笑的事，可以使用<code>t[2].extend([50, 60])</code>避免这个问题。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python对序列使用+和*以及一个陷阱]]></title>
      <url>/2018/03/03/Python%E5%AF%B9%E5%BA%8F%E5%88%97%E4%BD%BF%E7%94%A8-%E5%92%8C*/</url>
      <content type="html"><![CDATA[<h1 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h1><p>Python中，可以使用<code>+</code>和<code>*</code>对序列进行拼接，形成一个全新的序列，原序列保持不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; l * 3</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; 2 * &apos;abc&apos;</span><br><span class="line">&apos;abcabc&apos;</span><br></pre></td></tr></table></figure>
<p>这个相信很多Python程序员都会很经常用到，但这里面会有一个陷阱，下面一个例子说明一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_list = [[&apos;_&apos;] * 3] * 3  # 形成一个3*3的序列</span><br><span class="line">&gt;&gt;&gt; my_list</span><br><span class="line">[[&apos;_&apos;, &apos;_&apos;, &apos;_&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;_&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;_&apos;]]</span><br><span class="line">&gt;&gt;&gt; my_list[1][2] = &apos;X&apos;   		# 对序列其中一个元素进行修改</span><br><span class="line">&gt;&gt;&gt; my_list</span><br><span class="line">[[&apos;_&apos;, &apos;_&apos;, &apos;X&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;X&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;X&apos;]]</span><br></pre></td></tr></table></figure>
<h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p>后面的结果和预想的并不一样，不只是 <code>my_list[1][2]</code> 的位置里发生了改变，而是全部 <code>my_list[x][2]</code> 里面都都发生了改变。</p>
<p>导致这一原因是因为，如果用<code>my_list = [[&#39;_&#39;] * 3] * 3</code>来初始化序列，里面的3个元素都是引用，而不是新的序列。</p>
<p><strong>注意:</strong> <code>[&#39;_&#39;] * 3</code> 这样单个列表使用<code>*</code>是不会出现上面那样的情况的，只有当列表有嵌套的时候，如<code>[[]] * 3</code>才会发生。</p>
<p>可以使用下面的例子来解决刚才的问题。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_list = [[&apos;_&apos;] * 3 for i in range(3)]   </span><br><span class="line">&gt;&gt;&gt; my_list</span><br><span class="line">[[&apos;_&apos;, &apos;_&apos;, &apos;_&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;_&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;_&apos;]]</span><br><span class="line">&gt;&gt;&gt; my_list[1][2] = &apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; my_list</span><br><span class="line">[[&apos;_&apos;, &apos;_&apos;, &apos;_&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;X&apos;], [&apos;_&apos;, &apos;_&apos;, &apos;_&apos;]]</span><br></pre></td></tr></table></figure>
<h4 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h4><p>主要是在列表初始化的时候，使用列表推导的方式生成一个 3*3 的序列，这样，里面的每一个元素都是一个独立的序列。</p>
<h2 id="对于错误的理解"><a href="#对于错误的理解" class="headerlink" title="对于错误的理解"></a>对于错误的理解</h2><p>上面提到的那个陷阱，可以用下面的例子明确的展示出来</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row = [<span class="string">'_'</span>] * <span class="number">3</span></span><br><span class="line">my_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	my_list.append(row)</span><br></pre></td></tr></table></figure>
<p>这样看起来就很容易理解上面陷阱的原因了。</p>
<p>相对于上面<strong>正确</strong>代码用以下的例子明确地展示。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	row = [<span class="string">'_'</span>] * <span class="number">3</span></span><br><span class="line">	my_list.append(row)</span><br></pre></td></tr></table></figure>
<p>如果对于以上还不理解的话，建议百度找找关于引用类型的说明，如果学过C语言里面的指针的话，也是同一个道理。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python列表推导]]></title>
      <url>/2018/02/15/Python%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC/</url>
      <content type="html"><![CDATA[<h1 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h1><p>列表推导是Python中一个非常好用的特性，而且看起来也非常易懂，在很多时候都可以用来替代传统的<code>for</code>循环。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>将一段字符串转为ASCII编码形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chars = &apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; codes=[]</span><br><span class="line">&gt;&gt;&gt; for c in chars:</span><br><span class="line">	codes.append(ord(c))</span><br><span class="line">&gt;&gt;&gt; codes</span><br><span class="line">[65, 66, 67]</span><br></pre></td></tr></table></figure>
<p>这个例子非常简单，看起来也很清晰，但是，做这么一件简单的事却要花4行代码来解决。使用列表推导的方式两行代码就能搞定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chars = &apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; codes = [ord(c) for c in chars]</span><br><span class="line">&gt;&gt;&gt; codes</span><br><span class="line">[65, 66, 67]</span><br></pre></td></tr></table></figure>
<p>看起来非常的简洁，它其实就是<code>for</code>循环的一种简写，能够完全替代一些简单的<code>for</code>语句，起到更简洁的作用。但如果列表推导里面的代码超过两行，那么就要考虑用<code>for</code>来替换了，因为会导致代码可读性降低，造成维护困难。</p>
<h2 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子"></a>复杂一点的例子</h2><p>在 <a href="http://ougaojun.com/2018/02/12/%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">Python特殊方法</a> 里面的一个例子，有这么一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self._cards = [Card(rank, suit) for suit in self.suits</span><br><span class="line">   					for rank in self.ranks]</span><br></pre></td></tr></table></figure>
<p>就用到了嵌套的列表推导，在这里，可读性依然很强，因为这里的<code>suit</code>和<code>rank</code>是属于同一个对象的两个属性，不会造成错乱的感觉。</p>
<h2 id="列表推导的变量泄露问题"><a href="#列表推导的变量泄露问题" class="headerlink" title="列表推导的变量泄露问题"></a>列表推导的变量泄露问题</h2><p>在<code>Python2</code>中，列表推导中<code>for</code>关键词之后的赋值操作可能会影响上下文的同名变量，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python 2.7.10 (default, Jul 15 2017, 17:16:57) </span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.31)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; x = &apos;example&apos;</span><br><span class="line">&gt;&gt;&gt; test = [x for x in &apos;ABC&apos;]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&apos;C&apos;</span><br></pre></td></tr></table></figure>
<p><code>x</code>原本的值被取代了，但是在<code>Python3</code>中，这种情况是不会出现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Python 3.6.3 (v3.6.3:2c5fed86e0, Oct  3 2017, 00:32:08) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; x = &apos;python3&apos;</span><br><span class="line">&gt;&gt;&gt; test = [x for x in &apos;ABC&apos;]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&apos;python3&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python内置序列类型]]></title>
      <url>/2018/02/15/Python%E5%86%85%E7%BD%AE%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h1><p>按照类型划分Python里面的序列，可分为<strong>容器序列</strong>和<strong>扁平序列</strong></p>
<h4 id="容器序列"><a href="#容器序列" class="headerlink" title="容器序列"></a>容器序列</h4><p><code>list</code>、<code>tuple</code> 和 <code>collections.deque</code> 这些序列能存放不同类型的数据。</p>
<h4 id="扁平序列"><a href="#扁平序列" class="headerlink" title="扁平序列"></a>扁平序列</h4><p><code>str</code>、<code>bytes</code>、<code>bytearray</code>、<code>memoryview</code> 和 <code>array.array</code>，这类序列只能容纳一种类型。</p>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。</p>
<h5 id="序列类型还能按照能否被修改来分类。"><a href="#序列类型还能按照能否被修改来分类。" class="headerlink" title="序列类型还能按照能否被修改来分类。"></a>序列类型还能按照能否被修改来分类。</h5><h4 id="可变序列"><a href="#可变序列" class="headerlink" title="可变序列"></a>可变序列</h4><p><code>list</code>、<code>bytearray</code>、<code>array.array</code>、<code>collections.deque</code> 和 <code>memoryview</code>。</p>
<h4 id="不可变序列"><a href="#不可变序列" class="headerlink" title="不可变序列"></a>不可变序列</h4><p><code>tuple</code>、<code>str</code> 和 <code>bytes</code>。</p>
<p>下图显示了可变序列（MutableSequence）和不可变序列（Sequence）的差异，同时也能看出前者从后者那里继承了一些方法。虽然内置的序列类型并不是直接从 Sequence 和 MutableSequence 这两个抽象基类（Abstract Base Class，ABC）继承而来的，但是了解这些基类可以帮助我们总结出那些完整的序列类型包含了哪些功能。</p>
<p><img src="/2018/02/15/Python内置序列类型/序列继承关系.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python切片操作]]></title>
      <url>/2018/02/13/Python%E5%88%87%E7%89%87/</url>
      <content type="html"><![CDATA[<h1 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h1><p>每个Python程序员都知道像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作，但实际上的切片操作比人们所想象的要强大的多。</p>
<h2 id="简单一点的切片"><a href="#简单一点的切片" class="headerlink" title="简单一点的切片"></a>简单一点的切片</h2><p>少废话，上例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = [1,2,3,4,5,6,7,8,9,0]</span><br><span class="line">&gt;&gt;&gt; n[:2]</span><br><span class="line">[1, 2]</span><br><span class="line">&gt;&gt;&gt; n[2:]</span><br><span class="line">[3, 4, 5, 6, 7, 8, 9, 0]</span><br><span class="line">&gt;&gt;&gt; n[2:4]</span><br><span class="line">[3, 4]</span><br><span class="line">&gt;&gt;&gt; n[2:-2]</span><br><span class="line">[3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>
<p>我想应该不用做过多的解释。</p>
<h2 id="难一点的切片"><a href="#难一点的切片" class="headerlink" title="难一点的切片"></a>难一点的切片</h2><p>我们还可以使用<code>s[a:b:c]</code>形式的操作，对s在a和b之间以c为间隔取值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &apos;tensorflow&apos;</span><br><span class="line">&gt;&gt;&gt; s[::3]</span><br><span class="line">&apos;tsfw&apos;</span><br><span class="line">&gt;&gt;&gt; s[::-1]</span><br><span class="line">&apos;wolfrosnet&apos;</span><br><span class="line">&gt;&gt;&gt; s[2:-2:2]</span><br><span class="line">&apos;nof&apos;</span><br></pre></td></tr></table></figure>
<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p><code>s[::3]</code>：这里的<code>3</code>是间隔，也就是步长，每隔3个数取一个值。</p>
<p><code>s[::-1]</code>：每隔-1个数取一个值，也就是倒着取值。</p>
<p><code>s[2:-2:2]</code>：从2的位置到倒数第2个位置以每隔2个位置取一个值。</p>
<h2 id="给切片赋值"><a href="#给切片赋值" class="headerlink" title="给切片赋值"></a>给切片赋值</h2><p>先看代码实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = list(range(10))</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; l[2:5] = [20, 30]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 20, 30, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; del l[5:7]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 20, 30, 5, 8, 9]</span><br><span class="line">&gt;&gt;&gt; l[2::2] = [11, 22, 33]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 1, 11, 30, 22, 8, 33]</span><br><span class="line">&gt;&gt;&gt; l[1:3]=10</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#73&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    l[1:3]=10</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line">&gt;&gt;&gt; l[1:3]=[10]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0, 10, 30, 22, 8, 33]</span><br></pre></td></tr></table></figure>
<h4 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h4><p><code>l[2::2]= [11, 22, 33]</code>：这里只能赋值3个数，不能多也不能少，因为起始和间隔都是固定死的。</p>
<p><code>l[1:3]=10</code>：这样会报错。如果赋值对象是一个切片，那么右侧就必须是个可迭代对象，即使只有一个值。</p>
<h2 id="多维切片和省略"><a href="#多维切片和省略" class="headerlink" title="多维切片和省略"></a>多维切片和省略</h2><p>在NumPy外部库，二维的<code>numpy.ndarray</code>可以使用<code>a[i, j]</code>这样的是形式来获取值，抑或是用<code>a[m:n, k:l]</code>的方式来得到二维切片。</p>
<p>省略号（…）正确书写时三个英文句号。在Python解析器里是一个符号，而实际它是<code>Ellipsis</code>对象的别名，这些无关紧要，重要的是它的用法还有作用。但在这一节里，还不属于Python自带库的用法，我会单独开一个关于<code>NumPy</code>切片的贴来写说明这一切。</p>
<p>链接：<u><em>未完待续</em></u></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python元组详解]]></title>
      <url>/2018/02/12/Python%E5%85%83%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="Python元组"><a href="#Python元组" class="headerlink" title="Python元组"></a>Python元组</h1><p>Python元组是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义。</p>
<p>下面看一段代码就能很直观的看到元组的使用和意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = (2, 3)</span><br><span class="line">&gt;&gt;&gt; name, age = (&apos;JZen&apos;, 20)</span><br><span class="line">&gt;&gt;&gt; persons = [(&apos;Jack&apos;, 23), (&apos;Mary&apos;, 22), (&apos;Tom&apos;, 20)]</span><br><span class="line">&gt;&gt;&gt; for p in sorted(persons):</span><br><span class="line">	print(&apos;name:%s, age:%d&apos; % p)</span><br><span class="line"></span><br><span class="line">name:Jack, age:23</span><br><span class="line">name:Mary, age:22</span><br><span class="line">name:Tom, age:20</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for name, _ in persons:</span><br><span class="line">	print(name)</span><br><span class="line"></span><br><span class="line">Jack</span><br><span class="line">Mary</span><br><span class="line">Tom</span><br></pre></td></tr></table></figure>
<h2 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h2><p>元组拆包的形式就是平行赋值，少废话，看代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = (1,2)</span><br><span class="line">&gt;&gt;&gt; one, two = nums</span><br><span class="line">&gt;&gt;&gt; one</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; two</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>另外，还有一种很优雅的写法，当你要交换两个变量的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>
<p>可以用下滑线替换不需要的值</p>
<h2 id="在方法返回值中使用"><a href="#在方法返回值中使用" class="headerlink" title="在方法返回值中使用"></a>在方法返回值中使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(a, b)</span></span></span><br><span class="line">	return a+b, a*b</span><br><span class="line"></span><br><span class="line">sum, mul = calculate(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sum = 5, mul = 6</span></span><br></pre></td></tr></table></figure>
<h2 id="关于-号的用法"><a href="#关于-号的用法" class="headerlink" title="关于*号的用法"></a>关于*号的用法</h2><p>可以用 * 运算符把一个可迭代对象拆开作为函数的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(20, 8)</span><br><span class="line">(2, 4)</span><br><span class="line">&gt;&gt;&gt; t = (20, 8)</span><br><span class="line">&gt;&gt;&gt; divmod(*t)</span><br><span class="line">(2, 4)</span><br></pre></td></tr></table></figure>
<p>用*来处理剩下的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, *rest = range(5)</span><br><span class="line">&gt;&gt;&gt; a, b, rest</span><br><span class="line">(0, 1, [2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; a, b, *rest = range(2)</span><br><span class="line">&gt;&gt;&gt; a, b, rest</span><br><span class="line">(0, 1, [])</span><br><span class="line">&gt;&gt;&gt; a, *rest, b = range(5)</span><br><span class="line">&gt;&gt;&gt; a, b, rest</span><br><span class="line">(0, 4, [1, 2, 3])</span><br></pre></td></tr></table></figure>
<p>*号只能用在变量名的前面</p>
<h2 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h2><p>顾名思义，就是带有名字的元组，这里的名字是指<code>name</code>或者<code>key</code></p>
<p>具体是使用<code>collections.namedtuple</code>函数。他是一个工厂函数，用来构建一个带有字段名的元组和一个有名字的类。调试程序的时候会很舒服。</p>
<p>使用之前先import</p>
<p><code>from collections import namedtuple</code></p>
<p>然后看下面例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Person = namedtuple(&apos;Person&apos;, &apos;name age gender&apos;)</span><br><span class="line">&gt;&gt;&gt; JZen = Person(&apos;JZen&apos;, 20, &apos;male&apos;)</span><br><span class="line">&gt;&gt;&gt; JZen</span><br><span class="line">Person(name=&apos;JZen&apos;, age=20, gender=&apos;male&apos;)</span><br><span class="line">&gt;&gt;&gt; JZen.name</span><br><span class="line">&apos;JZen&apos;</span><br><span class="line">&gt;&gt;&gt; JZen[1]</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>这样看一遍我想应该都明白了吧。主要是<code>namedtuple</code>方法里面的两个参数，第一个参数是<code>typename</code>，这个可以取一个比较好认的名字，这取决于你自己。重点是第二个参数，可以是一段字符串，也可以是一个包含字符串的可迭代集合，比如上面那行可以写成这样：</p>
<p><code>namedtuple(&#39;Person&#39;, [&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;])</code></p>
<p>除了从普通元组继承来的属性之外，具名元组还有一些自己专有的属性。下面展示几个最有用的：<code>_fields</code>类属性、类方法<code>_make(iterable)</code>和实例方法<code>_asdict()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Person._fields</span><br><span class="line">(&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;)</span><br><span class="line">&gt;&gt;&gt; jack_info = (&apos;Jack&apos;, 18, &apos;male&apos;)</span><br><span class="line">&gt;&gt;&gt; Jack = Person._make(jack_info)</span><br><span class="line">&gt;&gt;&gt; Jack._asdict()</span><br><span class="line">OrderedDict([(&apos;name&apos;, &apos;Jack&apos;), (&apos;age&apos;, 18), (&apos;gender&apos;, &apos;male&apos;)])</span><br><span class="line">&gt;&gt;&gt; for key, value in Jack._asdict().items():</span><br><span class="line">	print(key, &apos;:&apos;, value)</span><br><span class="line">	</span><br><span class="line">name : Jack</span><br><span class="line">age : 18</span><br><span class="line">gender : male</span><br></pre></td></tr></table></figure>
<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p><code>_fields</code>：包含着这个元组的所有字段名称的属性</p>
<p><code>_make(jack_info)</code>：和<code>Person(*jack_info)</code>作用一样。</p>
<p><code>_asdict()</code>：把具名元组以<code>collections.OrderedDict</code>的形式返回，利用它我们可以友好地将元组的信息呈现出来。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python特殊方法]]></title>
      <url>/2018/02/12/%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>魔术方法（magic method）是特殊方法的昵称，在Python中的特殊方法，一般都是使用诸如<code>__xxx__</code>（前后两个下划线，中间是方法名）的命名方式，在书里有个名词也可以形容它，比如<code>__getitem__</code>，叫做“双下—getitem” (dunnder-getitem)</p>
<h2 id="万事开头难"><a href="#万事开头难" class="headerlink" title="万事开头难"></a>万事开头难</h2><p>难以用概念去概括Python特殊方法的作用，最简单的方法就是用例子说明。</p>
<p>很多人都会选择使用Python作为快速开发工具，而特殊方法是属于“快速”这个性质。</p>
<p>在Python中，要拿到一个集合的某个元素，可以使用对应的引索进行取值，比如<code>list[key]</code>，这背后利用的是<code>__getitem__</code>方法，为了拿到<code>my_list[key]</code>的值，解释器实际上会调用<code>my_list.__getitem__(key)</code>。</p>
<p>Python也是面向对象编程语言，对于求一个集合的长度使用<code>len(list)</code>而不是<code>list.len()</code>会感觉有点奇怪，背后就是特殊方法的作用，调用了<code>list.__len__()</code>方法，和面向对象完全符合，而且还起到简化的作用，变得更加通俗易懂。</p>
<h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>,[<span class="string">'rank'</span>, <span class="string">'suit'</span>])   <span class="comment"># 具名元组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)  <span class="comment"># 牌数 </span></span><br><span class="line">    suits = <span class="string">'spades hearts clubs diamonds'</span>.split()        <span class="comment"># 牌色</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>                            <span class="comment"># 初始化（构造函数）</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span>                             <span class="comment"># 用len取长度的特殊方法</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span>               <span class="comment"># 用引索取值的特殊方法</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; deck = FrenchDeck()</span><br><span class="line">&gt;&gt;&gt; len(deck)</span><br><span class="line">52</span><br><span class="line">&gt;&gt;&gt; deck[0]</span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;spades&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="随机抽牌"><a href="#随机抽牌" class="headerlink" title="随机抽牌"></a>随机抽牌</h4><p>那么我们可以使用random模块里面的一个方法随机抽取一张牌</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from random import choice</span><br><span class="line">&gt;&gt;&gt; choice(deck)</span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;clubs&apos;)</span><br><span class="line">&gt;&gt;&gt; choice(deck)</span><br><span class="line">Card(rank=&apos;J&apos;, suit=&apos;clubs&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h4><p>既然我们实现了引索中括号[]操作，那么我们也可以使用切片操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; deck[:3]</span><br><span class="line">[Card(rank=&apos;2&apos;, suit=&apos;spades&apos;), Card(rank=&apos;3&apos;, suit=&apos;spades&apos;), </span><br><span class="line">Card(rank=&apos;4&apos;, suit=&apos;spades&apos;)]</span><br><span class="line">&gt;&gt;&gt; deck[12::13]</span><br><span class="line">[Card(rank=&apos;A&apos;, suit=&apos;spades&apos;), Card(rank=&apos;A&apos;, suit=&apos;hearts&apos;), </span><br><span class="line">Card(rank=&apos;A&apos;, suit=&apos;clubs&apos;), Card(rank=&apos;A&apos;, suit=&apos;diamonds&apos;)]</span><br></pre></td></tr></table></figure>
<h4 id="迭代操作"><a href="#迭代操作" class="headerlink" title="迭代操作"></a>迭代操作</h4><p>另外，仅仅实现了<code>__getitem__</code>方法，那么也变成了可迭代的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for card in deck: # 反向迭代也可以 reversed(deck)</span><br><span class="line">	print(card)</span><br><span class="line"></span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;spades&apos;)</span><br><span class="line">Card(rank=&apos;3&apos;, suit=&apos;spades&apos;)</span><br><span class="line">Card(rank=&apos;4&apos;, suit=&apos;spades&apos;)</span><br><span class="line">···</span><br><span class="line">Card(rank=&apos;Q&apos;, suit=&apos;diamonds&apos;)</span><br><span class="line">Card(rank=&apos;K&apos;, suit=&apos;diamonds&apos;)</span><br><span class="line">Card(rank=&apos;A&apos;, suit=&apos;diamonds&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h4><p>如果一个集合没有实现<code>__contains__</code>方法，那么<code>in</code>运算符会按顺序做一次迭代搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Card(&apos;A&apos;, &apos;hearts&apos;) in deck</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Card(&apos;B&apos;, &apos;hearts&apos;) in deck</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>按照扑克牌的大小，2最小，A最大，同时要加上花色的大小判定，从大到小排序：黑桃、红桃、梅花、方块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suit_values = dict(spades = <span class="number">3</span>, hearts = <span class="number">2</span>, clubs = <span class="number">1</span>, diamonds = <span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span><span class="params">(card)</span>:</span></span><br><span class="line">	rank_value = FrenchDeck.ranks.index (card.rank)</span><br><span class="line">	<span class="keyword">return</span> rank_value * len(suit_values) + suit_values[card.suit]</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for card in sorted(deck, key = spades_high):</span><br><span class="line">	print(card)</span><br><span class="line"></span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;diamonds&apos;)</span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;clubs&apos;)</span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;hearts&apos;)</span><br><span class="line">Card(rank=&apos;2&apos;, suit=&apos;spades&apos;)</span><br><span class="line">···</span><br><span class="line">Card(rank=&apos;A&apos;, suit=&apos;diamonds&apos;)</span><br><span class="line">Card(rank=&apos;A&apos;, suit=&apos;clubs&apos;)</span><br><span class="line">Card(rank=&apos;A&apos;, suit=&apos;hearts&apos;)</span><br><span class="line">Card(rank=&apos;A&apos;, suit=&apos;spades&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>/2018/02/08/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级</span><br><span class="line">###  3</span><br><span class="line">####  4</span><br><span class="line">#####  5</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 苟利国家生死以，其因祸福避趋之。  </span><br><span class="line">&gt; -- 长者</span><br></pre></td></tr></table></figure>
<blockquote>
<p>苟利国家生死以，其因祸福避趋之。<br>​– 长者</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* abc</span><br><span class="line">* abc</span><br></pre></td></tr></table></figure>
<ul>
<li>abc</li>
<li>abc</li>
</ul>
<p><code>*</code> 可以用 <code>+</code> 或者 <code>-</code> 代替</p>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 写一个自动关机程序</span><br><span class="line">2. 设置为自启</span><br></pre></td></tr></table></figure>
<ol>
<li>写一个自动关机程序</li>
<li>设置为自启</li>
</ol>
<p><strong>数字不会影响输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 按照第一行的序号开始排列</span><br><span class="line">6. 这里不管是啥数字，都会是2</span><br></pre></td></tr></table></figure>
<ol>
<li>按照第一行的序号开始排列</li>
<li>这里不管是啥数字，都会是2</li>
</ol>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>下面的都可以用作分割线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是**加粗**的</span><br></pre></td></tr></table></figure>
<p>这是<strong>加粗</strong>的</p>
<h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是*倾斜*的</span><br></pre></td></tr></table></figure>
<p>这是<em>倾斜</em>的</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s&gt;卖萌嘟嘴剪刀手&lt;/s&gt;</span><br></pre></td></tr></table></figure>
<p><s>卖萌嘟嘴剪刀手</s></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;这个只能用html标签了&lt;/u&gt;</span><br></pre></td></tr></table></figure>
<p><u>这个只能用html标签了</u></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度一下](http://blog.ougaojun.com)</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.ougaojun.com" target="_blank" rel="noopener">百度一下</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http://blog.ougaojun.com/upload/2017/11/rhahu42vmmg95qjjr2fist5ps4.png)</span><br></pre></td></tr></table></figure>
<p><strong><img src="http://blog.ougaojun.com/upload/2017/11/rhahu42vmmg95qjjr2fist5ps4.png" alt=""></strong></p>
<h1 id="Markdown-进阶语法"><a href="#Markdown-进阶语法" class="headerlink" title="Markdown 进阶语法"></a>Markdown 进阶语法</h1><h2 id="目录大纲"><a href="#目录大纲" class="headerlink" title="目录大纲"></a>目录大纲</h2><p>这个在此博客中不支持，所以就以图片的形式展示效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[toc]</span><br></pre></td></tr></table></figure>
<p><img src="http://blog.ougaojun.com/upload/2017/11/6gc2063usmijnp8nr5k3mntq52.jpg" alt=""></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|姓名|性别|</span><br><span class="line">|---|:---:|</span><br><span class="line">|赵日天|女|</span><br><span class="line">|长者|男|</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td>赵日天</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td>长者</td>
<td style="text-align:center">男</td>
</tr>
</tbody>
</table>
<p>这里面第二行<code>---</code>里面的<code>-</code>号可以是任意个。</p>
<p><code>:--</code> 左对齐</p>
<p><code>--:</code> 右对齐</p>
<p><code>:--:</code> 居中</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​` ` `python</span><br><span class="line">print(&quot;Hello World！&quot;)</span><br><span class="line">` ` `</span><br><span class="line">把空格去掉，因为这里有冲突，没处理好。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello World！"</span>)</span><br></pre></td></tr></table></figure>
<p>这里可以指定某种语言</p>
<h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`printf(&quot;Hello World&quot;);`</span><br></pre></td></tr></table></figure>
<p><code>printf(&quot;Hello World&quot;);</code></p>
<p>这里就是单纯的一行代码块</p>
<h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://blog.ougaojun.com/&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.ougaojun.com/" target="_blank" rel="noopener">http://blog.ougaojun.com/</a></p>
<h2 id="Flow-流程图"><a href="#Flow-流程图" class="headerlink" title="Flow 流程图"></a>Flow 流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">​` ` `flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: 执行</span><br><span class="line">cond=&gt;condition: 是或否</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">​` ` `</span><br></pre></td></tr></table></figure>
<p><img src="http://blog.ougaojun.com/upload/2017/11/vubum9id2ojqqqkqn0k972ai0i.jpg" alt=""></p>
<h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 写博客</span><br><span class="line">- [ ] 敲代码</span><br><span class="line">- [x] 写进阶教程</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> 写博客</li>
<li style="list-style: none"><input type="checkbox"> 敲代码</li>
<li style="list-style: none"><input type="checkbox" checked> 写进阶教程</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$c^2 = a^2 + b^2$$</span><br></pre></td></tr></table></figure>
<p>$$c^2 = a^2 + b^2$$</p>
<p>需要MathJax的支持，加入js就可以显示了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span></span><br><span class="line">  src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">笛卡尔坐标系[^1]</span><br><span class="line"></span><br><span class="line">[^1]: 就是直角坐标系</span><br></pre></td></tr></table></figure>
<p>笛卡尔坐标系<a href="就是直角坐标系">^1</a></p>
<hr>
<p>PS：因为一部分markdown在本博客系统不受支持，所以用图片代替。</p>
<p>2017.11.21：完成初稿。</p>
<p>2017.11.22：修复一个错误，删除线不支持，用 <code>&lt;s&gt;&lt;/s&gt;</code> 代替。</p>
]]></content>
      
        <categories>
            
            <category> 科普 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>/2018/02/07/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本博客基于 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a> + <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 搭建，主题使用 <a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">Material Theme</a>。</p>
<p>2018-02-07 23:09</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
